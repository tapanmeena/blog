---
interface Props {
  /** Number of items to show initially */
  initialCount?: number;
  /** Number of items to load on each scroll */
  loadCount?: number;
}

const { initialCount = 6, loadCount = 6 } = Astro.props;
---

<div class="infinite-scroll-container" data-initial-count={initialCount} data-load-count={loadCount}>
  <div class="infinite-scroll-grid">
    <slot />
  </div>
  <div class="infinite-scroll-sentinel" aria-hidden="true"></div>
  <div class="infinite-scroll-loader" aria-live="polite">
    <div class="loader-spinner"></div>
    <span>Loading more posts...</span>
  </div>
  <div class="infinite-scroll-end" aria-live="polite">
    <span>You've reached the end!</span>
  </div>
</div>

<style>
  @reference "tailwindcss";

  @layer components {
    .infinite-scroll-container {
      @apply w-full;
    }

    .infinite-scroll-grid {
      @apply grid gap-6;
      grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
    }

    .infinite-scroll-grid > :global(*) {
      display: none;
    }

    .infinite-scroll-grid > :global(.visible) {
      display: block;
    }

    .infinite-scroll-sentinel {
      @apply h-1 w-full;
    }

    .infinite-scroll-loader {
      @apply hidden items-center justify-center gap-3 py-8;
      color: var(--color-muted);
    }

    .infinite-scroll-loader.loading {
      @apply flex;
    }

    .loader-spinner {
      @apply h-5 w-5 animate-spin rounded-full border-2;
      border-color: var(--color-border);
      border-top-color: var(--color-accent);
    }

    .infinite-scroll-end {
      @apply hidden items-center justify-center py-8 text-sm;
      color: var(--color-muted);
    }

    .infinite-scroll-end.show {
      @apply flex;
    }
  }
</style>

<script>
  class InfiniteScroll {
    private container: HTMLElement;
    private grid: HTMLElement;
    private sentinel: HTMLElement;
    private loader: HTMLElement;
    private endMessage: HTMLElement;
    private items: HTMLElement[];
    private visibleCount: number;
    private loadCount: number;
    private observer: IntersectionObserver | null = null;
    private isLoading: boolean = false;

    constructor(container: HTMLElement) {
      this.container = container;
      this.grid = container.querySelector(".infinite-scroll-grid")!;
      this.sentinel = container.querySelector(".infinite-scroll-sentinel")!;
      this.loader = container.querySelector(".infinite-scroll-loader")!;
      this.endMessage = container.querySelector(".infinite-scroll-end")!;

      this.items = Array.from(this.grid.children) as HTMLElement[];
      this.visibleCount = parseInt(container.dataset.initialCount || "6", 10);
      this.loadCount = parseInt(container.dataset.loadCount || "6", 10);

      this.init();
    }

    private init(): void {
      // Show initial items
      this.showItems(0, this.visibleCount);

      // Check if we already have all items visible
      if (this.visibleCount >= this.items.length) {
        this.showEndMessage();
        return;
      }

      // Set up Intersection Observer
      this.observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting && !this.isLoading) {
              this.loadMore();
            }
          });
        },
        {
          rootMargin: "100px",
        },
      );

      this.observer.observe(this.sentinel);
    }

    private showItems(start: number, end: number): void {
      for (let i = start; i < Math.min(end, this.items.length); i++) {
        this.items[i].classList.add("visible");
      }
    }

    private loadMore(): void {
      if (this.visibleCount >= this.items.length) {
        this.showEndMessage();
        return;
      }

      this.isLoading = true;
      this.loader.classList.add("loading");

      // Simulate a small delay for smooth UX
      setTimeout(() => {
        const newCount = Math.min(this.visibleCount + this.loadCount, this.items.length);
        this.showItems(this.visibleCount, newCount);
        this.visibleCount = newCount;

        this.loader.classList.remove("loading");
        this.isLoading = false;

        if (this.visibleCount >= this.items.length) {
          this.showEndMessage();
        }
      }, 300);
    }

    private showEndMessage(): void {
      if (this.observer) {
        this.observer.disconnect();
      }
      this.endMessage.classList.add("show");
    }
  }

  // Initialize all infinite scroll containers
  document.querySelectorAll(".infinite-scroll-container").forEach((container) => {
    new InfiniteScroll(container as HTMLElement);
  });
</script>
